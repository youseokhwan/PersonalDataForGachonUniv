2장 알고리즘을 배우기 위한 준비
1. 알고리즘의 특징
  - 정확성 : 항상 올바른 해를 구해야 함
  - 수행성 : 컴퓨터에서 수행할 수 있어야 함
  - 유한성 : 일정한 시간 내에 종료해야 함
  - 효율성 : 효율적일수록 가치가 높음
  - 입력 : 0개 이상의 입력으로 이루어짐
2. 최초의 알고리즘(유클리드)
Euclid(a, b)
if (b=0) return a
else Euclid(b, a mod b)

3장 분할 정복 알고리즘
1. 합병 정렬
  - 배열의 맨 왼쪽 인덱스를 left, 맨 오른쪽 인덱스를 right라고 할 때
  - left가 right보다 작으면 데이터를 절반으로 분할
  - 좌측 배열을 재귀적으로 합병 정렬
  - 우측 배열을 재귀적으로 합병 정렬
  - 분할했던 좌측 배열과 우측 배열을 정렬하면서 합병

2. 퀵 정렬
  - 배열의 맨 왼쪽 인덱스를 left, 맨 오른쪽 인덱스를 right라고 할 때
  - left가 right보다 작으면
  - 피봇을 선택하고 그 피봇의 인덱스를 p라고 할 때
  - 피봇보다 작은 값은 [left, p-1], 큰 값은 [p+1, right]로 자리 바꿈
  - 선택한 피봇과 인덱스p에 위치한 값을 자리 바꿈
  - Small group(left, p-1)을 재귀적으로 퀵 정렬
  - Large group(p+1, right)를 재귀적으로 퀵 정렬

3. 선택 문제
  - 배열의 맨 왼쪽 인덱스를 left, 맨 오른쪽 인덱스를 right, 찾으려는 수를 k번째 수라고 할 때
  - left가 right보다 작으면
  - 피봇을 선택하고 그 피봇의 인덱스를 p라고 할 때
  - 피봇보다 작은 값은 [left, p-1], 큰 값은 [p+1, right]로 자리 바꿈
  - 선택한 피봇과 인덱스 p에 위치한 값을 자리 바꿈
  - Small group의 크기는 S = p-left
  - 만약 k가 Small group의 크기보다 작거나 같다면 k는 Small group에 속한 것이므로
      Small group(left, p-1, k) 선택문제를 재귀적으로 호출
    만약 k가 S+1과 같다면 피봇을 반환
    만약 k가 Small group의 크기+1보다 크다면 k는 Large group에 속한 것이므로
      Large group(p+1, right, k-S-1) 선택문제를 재귀적으로 호출

4. 최근접 점의 쌍 찾기
  - x의 좌표를 기준으로 오름차순으로 정렬
  - 만약 점의 개수가 3개보다 같거나 적으면 3개 사이의 최근접 쌍을 반환
  - 만약 점의 개수가 3개보다 많으면 좌측과 우측으로 분할
  - 좌측에서 최근접 점의 쌍찾는 함수를 재귀적으로 호출
  - 우측에서 재귀적으로 호출
  - 둘 중 작은 값을 기준으로 중간 영역에 속하는 점들 중에서 최근접 쌍을 찾아서 3개중에 가장 작은 것을 반환

5. 피보나치 수
  - 피보나치는 분할처럼 보이지만 그냥 반복문으로 해결

4장 그리디 알고리즘
1. 동전 거스름돈
  - 거스름돈이 0원이 될때까지
      거스름돈을 넘지않으면서 가장 액면가가 높은 동전을 선택
      선택한 액면가만큼 거스름돈에서 빼고, 그 동전의 개수를 1 증가
  - 동전의 개수들의 합을 반환

2. 최소 신장 트리
  1) Kruskal MST
    - 각 선분들의 가중치를 기준으로 리스트 L에 오름차순 정렬
    - 트리 T를 공집합으로 초기화하고,
    - 트리 T의 선분의 개수가 기존 그래프의 선분의개수-1이 될때까지 루프
        L에서 가중치가 가장 작은 선분을 가져온다
        만약, 그 선분을 T에 추가했을 때 사이클이 생성되지 않으면
          T에 선분을 추가하고, L에서 선분을 삭제
        만약, 사이클이 생성되면
          L에서 선분을 삭제
    - 트리 T를 반환한다
  
  2) Prim MST
    - 임의의 점 p를 선택하고 트리 T에 추가한다.
    - p의 가중치 값은 0, 나머지 점은 무한대로 초기화한다.
    - p의 인접점들의 가중치를 갱신한다.
    - T의 노드의 수가 기존 그래프의 노드의 수와 같을 때까지
        T에 속하지 않은 점들 중 가중치가 최소인 점을 추가하고 그 선분을 연결한다
        추가된 점의 인접점들의 가중치를 최솟값이 되도록 갱신한다
    - 트리 T를 반환한다
    
3. 최단 경로 찾기
    - 다익스트라 알고리즘
    - 출발점 s의 가중치를 0으로 초기화하고, 나머지 점들은 무한대로 초기화한다.
    - 노드의 수-1 만큼 다음 루프를 실행한다
      최단거리가 확정되지 않은 점들 중 가중치가 가장 낮은 점을 선택한다
      출발점으로부터 그 점까지의 최단거리를 확정시킨다
      확정된 점의 인접점들의 가중치를 갱신한다

4. 부분 배낭 문제
  - 단위 무게당 가치를 기준으로 물질들을 내림차순으로 정렬
  - 가장 가치가 큰 물건을 가져온다
  - 무게의합+물건의무게가 배낭의 용량을 초과하지않을 때까지 루프
      무게의 합에 그 물건의 무게를 더하고
      가치의 합에 그 물건의 가치를 더함
      다음 가치가 큰 물건을 가져온다
  - 만약 초과한다면 배낭의 남은 용량만큼만 다음 가치가 큰 물건을 추가한다
  
5. 집합 커버 문제
  - 집합 C는 공집합으로 초기화
  - U가 공집합이 아닐때까지
      U의 원소들을 가장 많이커버하는 부분집합 S을 가져온다
      U에 U-S를 대입
      C에 S를 추가
  - C를 반환

6. 작업 스케줄링
  - 시작 시간을 기준으로 오름차순 정렬
  - 더 이상 배정할 작업이 없을 때까지 루프
      시작 시간이 가장 빠른 작업을 가져온다
      만약 그 작업을 수행할 수 있는 기계가 있으면
        해당 기계에 작업을 배치한다
      만약 그 작업을 수행할 수 있는 기계가 없으면
        새로운 기계에 작업을 배치한다

7. 허프만 압축
  - 각 값을 큐Q에 저장한다
  - Q의 노드의 개수가 2개 이상이면 루프
      가장 작은 값 2개를 가져온다
      2개의 합인 노드를 생성하고, Q에 삽입한다
      Q에서 그 2개의 값을 제거하고, 새로 생성한 노드의 자식노드로 삽입한다
  - 루프가 끝나면 트리를 기준으로 왼쪽에는 0, 오른쪽에는 1을 부여하여 허프만 코드를 부여한다
      
5장 동적 계획 알고리즘
1. 모든 쌍 최단 경로
  - 2차원 배열 D에 가중치를 초기화한다
    각 점 i, j에 대해 D[i, j]는 선분(i,j)의 가중치
    선분(i, j)가 없다면 무한대로 초기화하고, D[i, i]는 0으로 초기화
  - for k <- 1 to n
      for i <- 1 to n (단 i는 k와 같지 않다)
        for j <- 1 to n (단, j와 i, k와 같지 않다)
          D[i, j] = min{D[i,k]+D[k,j], D[i,j]}

2. 연속 행렬 곱셈
  - 
  
  
  
  
  
  
  
  