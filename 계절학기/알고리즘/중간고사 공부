시험 언급
- 퀵 정렬. 정렬이 끝날 때마다 'pass 1', 'pass 2' 명시
피벗이 무엇이였는지, 중간과정은 어떤지 등 상세하게 기술해야함
답은 모호하지않게 분명하게 작성할 것.. 왔다갔다하지말고 하나라도 명확히하라고 언급하심

Chapter 01 알고리즘의 첫걸음
  - 알고리즘 : 문제를 해결하기 위한 단계적인 절차
  - 9세기 페르시아 수학자 알 콰리즈미로부터 유래

1.1 최대 숫자 찾기
  - 순차 탐색(Sequential Search)
  - 숫자를 하나씩 비교하면서 가장 큰 숫자를 기억
  
1.2 임의의 숫자 찾기
  - 순차 탐색(Sequential Search)
  - 찾으려는 숫자를 기억한 후, 숫자를 하나씩 비교
  - 정렬된 데이터의 경우, 이진 탐색(Binary Search)

1.3 동전 거스름돈
  - 그리디(Greedy) 알고리즘
  - 가장 큰 액면가의 동전부터 선택하는 것

1.4 한붓그리기
  - 오일러 서킷(Euler Circuit)
  - 한붓그리기 : 연필을 떼지 않고 모든 선분을 지나 출발점으로 돌아오는 것
  - 현재 점으로 돌아오는 사이클(cycle)을 찾는 것

1.5 미로 찾기
  - 테세우스가 미노타우르스의 미로를 실타래를 되감으면서 탈출한데서 유래
  - 오른손 법칙

1.6 가짜 동전 찾기
  - 분할 정복(Divide and Conquer) 알고리즘
  1) 철수 : 임의의 동전 1개를 왼편에 놓고, 1개씩 비교 -> 최소 1번, 최대 n-1번
  2) 영희 : 2개씩 짝을 지어 비교 -> 최소 1번, 최대 n/2번
  3) 광수 : 전체를 2더미로 나누고, 가벼운 쪽을 계속해서 1개가 될 때까지 2더미로 분할 -> 최소, 최대 모두 log(n)번

1.7 독이 든 술단지
  - 2명의 신하가 4개의 술단지를 시음
    1) 철수 : 두 사람이 각각 한 단지씩 -> 나머지 2개 판별 불가
    2) 광수 : 한 사람이 각각 두 단지씩 -> 일주일이 더 필요하므로 불가
  - 2진수를 이용하여 해 찾기
  

Chapter 02 알고리즘을 배우기 위한 준비
2.1 알고리즘이란
  - 알고리즘의 특성
    1) 정확성 : 주어진 입력에 대한 올바른 해
    2) 수행성 : 컴퓨터에서 수행 가능해야 함
    3) 유한성 : 일정한 시간 내에 종료
    4) 효율성 : 시공간 효율성을 고려해야 함
    +) 입력(input) : 0개 이상의 입력
  
2.2 최초의 알고리즘
  - 유클리드의 최대공약수 알고리즘 : 큰 수에서 작은 수를 뺀 수와 작은 수의 최대공약수는 같다
~~~
Euclid(a, b)
01  if(b = 0) return a
02  return Euclid(b, a mod b)
~~~

2.3 알고리즘의 표현 방법
  - 일반적으로 의사 코드(pseudo code)로 표현
  - 최대 숫자를 찾는 알고리즘
~~~
01  max ← A[0]
02  for i ← 1 to 9
03    if(A[i] > max) then
04      max ← A[i]
05  return max
~~~

2.4 알고리즘의 분류
  - 알고리즘은 문제 혹은 해결 방식에 따라 여러 가지로 분류

2.5 알고리즘의 효율성 표현
  - 효율성은 일반적으로 시간복잡도로 표현
  - 시간복잡도 : 기본적인 연산 횟수를 입력 크기에 대한 함수로 표현
    1) 최악 경우 분석(일반적)
    2) 평균 경우 분석
    3) 최선 경우 분석

2.6 복잡도의 점근적 표기
  - 다항식을 단순하게 표현하기 위해 점근적 표기 사용
  - 다항식의 최고 차항만을 계수 없이 취한 것
    1) O(Big-Oh) 표기 : 점근적 상한
    2) Ω(Big-Omega) 표기 : 점근적 하한
    3) θ(Theta) 표기 : 상한, 하한
  - O(1) > O(logn) > O(n) > O(nlogn) > O(n^2) > O(n^3) > O(2^n)

2.7 왜 효율적인 알고리즘이 필요한가?
  - 입력이 커질수록 수행시간의 차이가 커지기 때문
  - 값비싼 H/W 개발보다 효율적인 알고리즘 개발이 더 경제적


Chapter 03 분할 정복 알고리즘
  - 문제의 입력을 부분문제로 분할하여 해결하고, 각 부분해를 다시 취합하여 해결하는 방법
  - 합병 정렬, 퀵 정렬, 이진 탐색, 선택 문제, 삽입 정렬, 피보나치 수열 등

3.1 합병 정렬
  - 2개의 부분문제로 분할하고 각 부분문제의 크기는 1/2로 감소
~~~
MergeSort(A, p, q)
01  if(p < q) {
02    k ← ⎣(p+q)/2⎦
03    MergeSort(A, p, k)
04    MergeSort(A, k+1, q)
05    A[p]~A[k] 합병, A[k+1]~A[q] 합병
    }
~~~
  - 시간 복잡도는 (층 수)*(합병 시 비교 횟수) = O(logn)*O(n) = O(nlogn)
  - 공간 복잡도는 합병된 결과를 저장할 임시 배열이 필요하므로 O(n)
  
3.2 퀵 정렬
  - 2개의 부분문제로 분할하나, 각 부분문제의 크기는 불규칙
  - 피봇을 기준으로 작으면 왼쪽, 크면 오른쪽으로 분류
~~~
QuickSort(A, left, right)
01  if(left < right) {
02    A[left]~A[right] 중 피봇 선택
      피봇과 A[left] 스왑
      피봇보다 작은 숫자는 A[left]~A[p-1], 큰 숫자는 A[p+1]~A[right]로 이동, 피봇은 A[p]로 이동
03    QuickSort(A, left, p-1)
04    QuickSort(A, p+1, right)
    }
~~~
  - 피봇 선택에 따라 시간복잡도 달라짐
    1) 최악 : 항상 가장 작은 숫자가 피봇 -> O(n^2)
    2) 최선 : 항상 중앙값이 피봇 -> O(nlogn)
    3) 평균 : O(nlogn)
  - 피봇은 left, mid, right 세 숫자 중 중앙값으로 선택

3.3 선택 문제
  - n개의 숫자들 중에서 k번째로 작은 숫자 선택
    1) 최소 숫자를 k번 찾고, k-1번까지는 최소 숫자를 지움 -> O(kn)
    2) 오름차순으로 정렬 후, k번째 인덱스 선택 -> O(nlogn)
    3) 피봇을 기준으로 2개로 분할하여 정복(1개의 부분문제는 고려할 필요 없고, 부분해를 합치는 과정 X) -> O(n)
~~~
Selection(A, left, right, k)
01  A[left]~A[right] 중 피봇 선택
    피봇과 A[left] 스왑
    피봇보다 작은 숫자는 A[left]~A[p-1], 큰 숫자는 A[p+1]~A[right]로 이동, 피봇은 A[p]로 이동
02  S ← p-left  // Small group의 크기
03  if(k ≤ S) Selection(A, left, p-1, k)
04  else if(k = S+1) return A[p]
05  else Selection(A, p+1, right, k-S-1)
~~~
  
3.4 최근접 점의 쌍 찾기
  - 클러스터링 문제
  - 최근접 점의 쌍을 찾는 간단한 방법은 모든 거리를 계산하여 가장 가까운 것을 찾는 것 O(n^2)
  - 여기서 좌우를 분할하되, 왼쪽의 맨 오른쪽 점과 오른쪽의 맨 왼쪽 점이 최근접 쌍일 수 있으므로
    min(left, right) 만큼의 center 구역을 동시에 고려해야 함

3.5 분할 정복을 적용하는 데 있어서 주의할 점
  - 입력이 분할될 때마다 부분문제의 입력 크기가 커지는 경우 부적절
  - 또는 취합 과정이 비효율적인 부분도 고려해야 함
  - 피보나치 수열은 분할 정복 대신 for문 사용 -> O(n)
~~~
FibNumber(n)
01  F[0] ← 0
02  F[1] ← 1
03  for i←2 to n
04    F[i] ← F[i-1]+F[i-2]
~~~


Chapter 04 그리디 알고리즘
  - 가능한 해 중 가장 좋은 해를 찾는 최적화 알고리즘
  - 한 번 선택하면 번복하지 않음

4.1 동전 거스름돈
  - 남은 액수를 초과하지 않는 한도에서 가장 큰 금액을 선택
~~~
01  change ← W  // W는 거스름돈
    n500 ← 0, n100 ← 0, n50 ← 0, n10 ← 0, n1 ← 0
02  while(change ≥ 500)
      change ← change-500, n500++
03  while(change ≥ 100)
      change ← change-100, n100++
04  while(change ≥ 50)
      change ← change-50, n50++
05  while(change ≥ 10)
      change ← change-10, n10++
06  while(change ≥ 1)
      change ← change-1, n1++
07  return n500+n100+n50+n10+n1
~~~
  - 항상 최적의 답은 아님 -> 추후에 동적 계획법으로 해결

4.2 최소 신장 트리
  - MST(Minimum Spanning Tree) : 사이클 없이 모든 점을 연결시킨 그래프 중 가중치의 합이 최소인 트리
  - 점의 수가 n이면 반드시 선분의 개수는 n-1
  - 대표적으로 Kruskal과 Prim 알고리즘
  1) KruskalMST
    - 사이클을 만들지않을 때에만 가장 낮은 가중치인 선분을 욕심내어 추가
    - 시간복잡도는 O(nlogn)
~~~
01  선분들의 가중치 리스트 L을 오름차순으로 정렬
02  T ← Ø
03  while(T의 선분 개수 < n-1) {
04    가장 작은 가중치인 선분 e를 가져오고, L에서 삭제
05    if(e를 T에 추가했을 때 사이클이 만들어지지 않으면)
06      e를 T에 추가
07    else
08      e를 버림
    }
09  return T
~~~

  2) PrimMST
    - 임의의 점을 선택하여 n-1개의 항상 최소의 가중치 선분을 욕심내어 추가
    - 시간복잡도는 O(n^2)
~~~
01  임의의 점 p를 선택, D[p] ← 0
02  for(점 p가 아닌 각 점 v) {
03    if(선분(p, v)가 존재하면)
04      D[v] ← 선분(p, v)의 가중치
05    else
06      D[v] ← ∞
    }
07  T ← {p}
08  while(T에 있는 점의 개수 < n) {
09    T에 속하지 않은 각 점 v에 대해, D[v]가 최소인 점과 그 선분(u, v)를 추가
      단, u는 T에 속한 점이고, 이때 v도 T에 추가
10    for(T에 속하지 않은 각 점 w) {
11      if(선분(u, v)의 가중치 < D[w])
12        D[w] ← 선분(v, w)의 가중치
      }
    }
13  return T
~~~

4.3 최단 경로 찾기
  - 다익스트라(Dijkstra) 알고리즘
  - PrimMST와 유사하나, 주어진 출발점에서 시작하고 선분을 추가할 때 가장 가까운 점을 추가하는 차이가 있다
~~~
01  배열 D를 ∞로 초기화, D[s] ← 0  // s는 출발점
02  while(s로부터의 최단 거리가 확정되지 않은 점이 존재하면) {
03    거리가 확정되지 않은 각 점 v에 대해 최소 D[v]값을 가진 v를 선택
      s와 v의 최단 거리 D[v]를 확정
04    점 v와 연결된 각 점 w에 대해 D[w]를 갱신
    }
05  return D
~~~

4.4 부분 배낭 문제
  - 최대의 가치를 갖도록 배낭을 채우는 문제
  - 단위 무게당 가치가 높은 물건부터 욕심내어 담는다
  - 시간복잡도는 O(nlogn)
  - 부분적으로 담을 수 없는 0-1 배낭문제는 동적 계획으로 추후에 해결
~~~
01  각 물건들의 단위 무게당 가치를 계산
02  리스트 S에 가치를 기준으로 물건들을 내림차순으로 정렬
03  L ← Ø, w ← 0, v ← 0  // L은 배낭에 담을 물건 리스트, w는 배낭에 담긴 무게의 합, v는 배낭에 담긴 가치의 합
04  S에서 가치가 가장 큰 물건 x를 가져온다
05  while(w+x의 무게 ≤ C) {  // C는 배낭의 용량
06    x를 L에 추가
07    w ← w+x의 무게
08    v ← v+x의 가치
09    x를 S에서 제거
10    S에서 가치가 큰 다음 물건 x를 가져온다
    }
11  if(C-w > 0) {
12    물건 x를 (C-w)만큼 L에 추가
13    v ← v+(C-w)만큼의 가치
    }
14 return L, v
~~~

4.5 집합 커버 문제
  - 부분 집합들의 합집합을 집합과 같게하되 그 수를 최소화하는 문제
  - 시간복잡도는 O(n^3)
~~~
01  C ← Ø  // C는 집합 커버
02  while(U ≠ Ø) {
03    U의 원소를 가장 많이 포함하는 집합 S를 F에서에서 선택  // F는 U의 부분집합들
04    U ← U-S
05    S를 F에서 제거하고, S를 C에 추가
    }
06  return C
~~~

4.6 작업 스케줄링
  - 작업의 수행 시간이 중복되지 않도록 가장 적은 수의 기계에 배정하는 문제(강의실 배정)
    1) 빠른 시작시간 우선
    2) 빠른 종료시간 우선
    3) 짧은 작업 우선
    4) 긴 작업 우선
  - 1번을 제외한 나머지는 항상 최적해를 찾지 못함
  - 시간복잡도는 O(nlogn)+O(mn)
~~~
01  리스트 L에 시작시간을 오름차순으로 정렬
02  while(L ≠ Ø) {
03    L에서 가장 빠른 시작시간을 가진 작업 t를 가져온다
04    if(t를 수행할 기계가 있으면)
05      t를 그 기계에 배정
06    else
07      t를 새로운 기계에 배정
08    t를 L에서 제거
    }
09  return 각 기계에 배정된 작업 순서
~~~

4.7 허프만 압축
  - 입력 파일에 대해 각 문자의 출현 빈도수에 기반을 둔 이진 트리를 만들고, 각 문자에 이진 코드(허프만 코드)를 할당
~~~
01  각 문자에 대해 노드를 만들고, 각 빈도수를 노드에 저장
02  각 빈도수에 대해 큐 Q를 생성
03  while(Q에 있는 노드 수 ≥ 2) {
04    빈도수가 가장 작은 2개의 노드 A와 B를 Q에서 제거
05    새 노드 N을 만들고, A와 B를 N의 자식 노드로 만든다
06    N의 빈도수 ← A의 빈도수 + B의 빈도수
07    노드 N을 Q에 삽입한다.
    }
08 return Q  // 허프만 트리의 루트를 반환
~~~
  - 접두부 특성(다른 코드의 접두부가 되지 않음)
  - 빈도수가 높은 노드는 트리에 속하며, 짧은 코드를 할당
  - 시간복잡도는 O(nlogn)


Chapter 05 동적 계획 알고리즘
  - 동적 계획 알고리즘은 입력 크기가 작은 부분문제들을 모두 해결한 후, 그 해를 이용하여 더 큰 부분문제들을 해결하는 최적화 문제

5.1 모든 쌍 최단 경로
  - 각 쌍 점 사이의 최단 경로를 찾는 문제
  - 각 점을 시작점으로 정하여 다익스트라 알고리즘 사용 O(n^3)
  - 플로이드-워셜 알고리즘 : 시간 복잡도는 동일하나 알고리즘이 매우 간단함
~~~
01  for k ← 1 to n
02    for i ← 1 to n (단, i ≠ k)
03      for j ← 1 to n (단, j ≠ k, j ≠ i)
04        D[i, j] ← min{D[i, k] + D[k, j], D[i, j]}
~~~

5.2 연속 행렬 곱셈