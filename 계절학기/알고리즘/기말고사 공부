알고리즘 기말고사

5장 동적 계획 알고리즘
5.3 편집 거리 문제
- 스트링 S를 T로 변환할 때 삽입, 삭제, 대치 연산이 사용되는데, 이 연산의 최소 횟수인 편집 거리를 구하는 문제
아이디어: 스트링 S와 T의 길이를 각각 m, n으로 정의
부분문제를 E[i,j]로 정의. S의 i개 문자를 T의 j개 문자로의 편집 거리
Si와 Tj의 문자를 비교하여 같으면 0, 다르면 삽입, 삭제, 대체의 최솟값을 비교하여 그 값+1

~~~EditDistance
입력 : 스트링 S, T. 길이는 각각 m, n
출력 : S를 T로 변환하는 편집 거리 E[m,n]
01 for i ← 0 to m
     E[i,0] ← i
02 for j ← 0 to n
     E[0,j] ← j
03 for i ← 1 to m
04   for j ← 1 to n
05     E[i,j] ← min{E[i,j-1]+1, E[i-1,j]+1, E[i-1,j-1]+𝜶}  // Si, Tj가 같으면 𝜶←0, 다르면 𝜶←1
06 return E[m,n]
~~~
- 시간 복잡도는 O(mn), 즉 O(1)이다.


5.4 배낭 문제
- 배낭의 용량 C일 때, 담을 수 있는 물건의 최대 가치를 찾는 문제
- 그리디 알고리즘과 다르게 0-1 배낭 문제는 물건이 1개씩만 있고, 부분적으로 담을 수 없다.
- 어떤 경우에도 최적해를 찾을 수 있으나, 용량 C가 너무 크면 시간이 너무 오래 걸려서 현실적으로 불가능하다.
아이디어: 임시 배낭 용량을 0에서부터 1씩 증가시키면서 그에 해당하는 최대 가치를 구함
부분문제를 K[i,w]로 정의. i는 물건 1~i개, w는 임시 배낭 용량(1~C)

~~~Knapsack
입력 : 배낭의 용량 C, n개의 물건과 각 물건 i에 대한 무게 w와 가치 v
출력 : K[n,C]
01 for i ← 0 to n  // 배낭의 용량이 0일 때
     K[i,0] ← 0
02 for w ← 0 to C  // 어떤 물건도 고려하지 않았을 때
     K[0,w] ← 0
03 for i ← 1 to n {  // 물건을 하나씩 추가하면서 고려
04   for w ← 1 to C {  // 임시 배낭의 용량을 1씩 늘리면서 고려
05     if(wi > w)  // 물건 i의 무게가 임시 배낭의 용량을 초과하면
06       K[i,w] ← K[i-1,w]  // 그 물건을 담지 않은 것과 같은 가치를 부여
07     else  // 초과하지 않으면
08       K[i,w] ← max{K[i-1,w], K[i-1,w-wi]+vi}  // 그 물건을 담은 것과 그렇지 않은 것의 무게 중 큰 가치를 부여
     }
   }
09 return K[n,C]
~~~
- 시간 복잡도는 O(nC)


5.5 동전 거스름돈
- 거스름돈 동전의 최소 개수를 찾는 문제
- 그리디 알고리즘과 다르게 항상 최적해를 찾을 수 있음
아이디어 : 배낭 문제처럼 거스름돈을 1원씩 증가시켜 가장 적은 수의 동전일 경우를 채택

~~~DPCoinChange
입력 : 거스름돈 n, k개의 동전 및 액면가 d1 > d2 > ... > dk=1
출력 : C[n]
01 for i ← 1 to n
     C[i] ← ∞
02 C[0] ← 0
03 for j ← 1 to n {  // j는 임시 거스름돈(1원씩 증가)
04   for i ← 1 to k {  // 액면가가 가장 높은 동전부터 1원짜리 동전까지
05     if(di ≤ j) and (C[j-di]+1 < C[j])
06       C[j] ← C[j-di]+1
     }
   }
07 return C[n]
~~~
- 시간 복잡도는 O(nk)


6장 정렬 알고리즘
6.5 힙 정렬
- 힙(heap) : 힙 조건을 만족하는 완전이진트리
// 힙은 우선순위 큐를 위해 만들어진 자료구조
// 최대, 최솟값을 빠르게 찾기 위해 만들어졌으며, 반정렬 상태(느슨한 정렬 상태)를 유지
// 완전이진트리 : 왼쪽부터 채워서 마지막 레벨을 제외하고 모두 자식노드를 가지고 있는 이진트리
// 힙 조건 : 각 노드의 값이 자식 노드의 값(우선순위)보다 큰 것
- A[0]은 비워두며, A[i] 기준, 부모는 A[i/2], 왼쪽 자식은 A[i*2], 오른쪽 자식은 A[i*2+1]
~~~HeapSort
입력 : 크기가 n+1인 배열 A
출력 : 정렬된 배열 A
01 배열 A에 대한 heap 자료구조 생성
02 heapSize ← n
03 for i ← 1 to n-1 {
04   A[1]과 A[heapSize]를 swap
05   heapSize ← heapSize-1
06   DownHeap()  // 힙 조건을 만족시키도록 재배열
   }
07 return A
~~~

~~~DownHeap
n은 heap의 크기, i는 부모 노드의 인덱스
01 LC ← 2*i
02 RC ← 2*i+1
03 if((LC < n) and (A[LC] > A[i]))
04   Big ← LC
05 else
06   Big ← i
07 if((RC < n) and (A[RC] > A[Big])
08   Big ← RC
09 if(Big ≠ i)
10   A[i]와 A[Big]을 swap
~~~

- Heap을 구성하는데 O(n), 정렬하는데 O(logn)이므로 O(nlogn)
- // 모든 값을 정렬하기보다는 최댓값 몇 개만 찾을 때 아주 효율적인 방법


7장 NP-완전 문제
7.1 문제 분류 / 7.2 NP-완전 문제의 특성
- P 문제 : 다항식의 시간복잡도 알고리즘을 가진 문제
- NP-완전 문제 : 지수 시간의 시간복잡도 알고리즘을 가진 문제
- NP 문제 : P와 NP-완전을 모두 포함, 비결정적 다항식 시간 알고리즘을 가진 문제
  1) 첫 번째 단계에서 하나의 해를 추측하고,
  2) 두 번째 단계에서 그 해를 다항식 시간에 확인한 후에
  3) 그 해가 맞는지 대답하는 과정
- 결정 문제 : 문제의 해가 yes/no가 되도록 문제를 변형(선형시간)
- NP-하드 문제 : 모든 NP문제가 문제 A로 다항식 시간에 변환이 가능하면 문제 A는 NP-하드 문제
  1) 문제 A는 NP문제이고, 동시에 NP-하드 문제이면 NP완전 문제가 된다.

7.3 NP-완전 문제의 소개
1) SAT(SATisfiability) : 부울 변수의 해를 찾는 문제
2) 부분 집합의 합 : 원소의 합이 K가 되는 집합 S의 부분 집합을 찾는 문제
3) 분할 : 집합 S를 분할하여 원소의 합이 같은 2개의 부분 집합으로 분할하는 문제
4) 0-1 배낭
5) 정점 커버 : 그래프 G=(V,E)에서 각 선분의 끝점들 중에서 적어도 1개의 점을 포함하는 점의 집합
6) 독립 집합 : 서로 연결하는 선분이 없는 점들의 집합
7) 클리크 : 그래프 G=(V,E)에서 모든 점들 사이를 연결하는 선분이 있는 부분 그래프
8) 그래프 색칠하기 : 그래프의 인접한 점들을 서로 다른 색으로 색칠하는 것
9) 집합 커버
10) 최장 경로
11) 여행자 경로(TSP) : 임의의 한 점에서 다른 모든 점들을 1번씩 방문하고, 다시 시작점으로 돌아오는 경로 중 최단 경로
12) 해밀토니안 사이클 : TSP에서 가중치가 모두 같음
13) 통 채우기 : 가장 적은 수의 통을 사용하여, 모든 물건을 통에 채우는 문제
14) 작업 스케줄링 : 모든 작업이 가장 빨리 종료되도록 배정하는 문제


8장 근사 알고리즘
- NP-완전 문제들은 다항식 알고리즘을 발견하지 못했으며, 다항식 시간에 풀 수 없다고 증명하지도 못했음
- 다음 중 1가지는 포기해야 함
  1) 다항식 시간에 해를 찾는 것
  2) 모든 입력에 대해 해를 찾는 것
  3) 최적해를 찾는 것
- 근사 알고리즘은 최적해를 찾는 것을 포기하고 근사해(Appr)를 구하는 것
- 근사해와 함께 근사비율을 제시해야 함

8.1 여행자 문제
- 임의의 한 노드에서 다른 모든 노드를 1번씩만 방문하고 다시 출발점으로 돌아오는 거리를 최소화하는 문제
- 여기선 대칭성+삼각 부등식 특성 적용

8.2 정점 커버 문제
8.3 통 채우기 문제
- n개의 모든 물건을 용량이 C인 통을 최소 개수만 사용하여 넣는 것
  1) 최초 적합 : 여유가 있는 최초의 통부터 채워 넣음
  2) 다음 적합 : 직전에 물건을 넣은 통에 여유가 있으면 새 물건을 넣음
  3) 최선 적합 : 새 물건이 들어갔을 때 남는 부분이 가장 적은 통에 새 물건을 넣음
  4) 최악 적합 : 새 물건이 들어갔을 때 남는 부분이 가장 많은 통에 새 물건을 넣음
  
~~~Approx_BinPacking
입력 : n개의 물건과 각각의 크기
출력 : 모든 물건을 넣는데 사용된 통의 수
01 B = 0
02 for i ← 1 to n {
03   if(물건 i를 넣을 여유가 있는 기존의 통이 있으면)
04     그리디 방법에 따라 정해진 통에 물건 i를 넣는다
05   else {
06     새 통에 물건 i를 넣는다
07     B ← B + 1
     }
   }
08 return B
~~~

8.4 작업 스케줄링 문제
8.5 클러스터링 문제


9장 해 탐색 알고리즘
9.1 백트래킹 기법
9.2 분기 한정 기법
9.3 유전자 알고리즘
9.4 모의 담금질 기법

