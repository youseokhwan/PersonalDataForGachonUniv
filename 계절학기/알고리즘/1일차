190624(월) 알고리즘 1주차

- 책 끝까지 나갈 예정?
- 실습하기는 좀 힘듬?
- 지각은 결석과 같은 처리(이유없고 결석은 결석)
- 코드는 Pseudo Code로 작성해야하는건지?
- 성적 비율?, 성적 비율 등 언급 X, 1주차 출석체크 안함

PPT)
- 알고리즘의 유래(8세기경 페르시아 수학자 ~, ~ 유클리드 최대공약수 알고리즘)
- 알고리즘 : 어떤 문제를 해결하기 위한 절차 // 보다 더 효율적인 알고리즘을 사용하지 않으면 틀리게 채점? (시간 복잡도)

- 가장 큰 숫자 찾기
- 모든 데이터를 하나씩 확인하는 방법 -> 순차 탐색(Sequential Search)

- 숫자 85 찾기
- // 알고리즘의 데이터는 대부분 배열에 저장돼있다.
- return i; 로 인덱스 반환
- 데이터가 100만개라면? -> 비효율적임 // 물론 정렬되지 않은 데이터에서는 어쩔 수 없긴함

- // 비교 횟수(연산 횟수)에 대한 언급, 알고리즘도 중요하지만 비교 횟수도 중요하다!
- // 최소, 최대(최악), 평균 효율
- // 보통은 최악의 경우만 따진다

- 만약 오름차순으로 정렬돼있다면? -> 이진 탐색(Binary Search)
- 이진 탐색할 때 데이터가 8개면 가운데가 4,5 나와서 아무거나 가능한데 // 일반적으로 몫인 4를 선택하시는 경향
- 대충 비교횟수 3번, 이진 탐색은 1000개여도 9번이면 찾음 O(logN)
- // 칠판에 Left, Right, Mid 변수 쓰시면서 코딩하심

- 동전 거스름돈
- 그리디 알고리즘(Greedy Algorithm) : 남은 거스름돈의 액수를 넘지 않으면서 계속 선택 // 탐욕
- // 알고리즘에서 =는 Equalization으로 보고 대입은 <- 으로 작성한다. // 슈도코드?
- // == 사용하면 틀리게 한다고 하심
- R-500처럼 뺄셈 반복 -> 나눗셈의 몫
- // 나머지는 %말고 mod 사용 mod(R, 500)

- 한붓그리기 // 오일러 서킷
- 모든 연결선 혹은 모든 점, 조건이 다를 수 있음 // 한붓그리기는 모든 선분을 한 번씩, 점은 여러 번 가능
- // 점을 한 번씩만 지나는 것들은 특별히 몇 개의 경우만 가능?
- 다시 해당 점으로 돌아오는 사이클을 찾는 것

- 미로 찾기
- 테세우스가 실타래를 다시 감으면서 미로를 빠져나온데서 유래
- 오른손 법칙(한쪽 방향으로만 진행)
- 미로는 2차원 배열로 표현
- // 무한 루프에 대한 언급은 없으셨음

- 가짜 동전 찾기 // 분할 정복
- 가짜 동전이 진짜 동전보다 가볍다, 무겁다에 대한 언급이 없으면 과정이 복잡해짐
- 여기선 가짜는 좀 더 가벼운 조건으로 주어짐
- 3가지 방법이 있는데, 더미를 반으로 나누는 방법이 가장 효율적인 방법
- // log의 경우 일반적으로 밑이 10인 경우가 많지만 컴공에서는 2를 많이쓰고 생략된 경우는 2인 것으로 생각할 것!

- 독이 든 술단지
- 2진수로 해결하는 알고리즘
- 최소 희생자로 가능

- 시험은 8번째, 혹은 진도가 안나가면 한 주 늦출수도 있음




